<!doctype html><html><head>
<title>JVJ: Knight's Max Flow</title>
<link rel="stylesheet" href="styles.css">
</head>
<body><h1>JVJ: Knight's Max Flow</h1>
<h4>Time-stamp: <2019-04-20 2:26AM JVJ></h4>
<h3>Flow    |   Capacity </h3> 
<canvas id="grid" width="800" height="800"></canvas>
	
<h5>Count of Unused/Unplaced Edges: #</h5> 
<h6>Current Flow Value: 0  (IF SRC HAS NOT BEEN CONNECTED TO SINK IT IS 0)</h5> 


</body>
<script src="draw-stuff.js"></script>
<script src="cell.js"></script>
<script src="Edge.js"></script>
<script>
    	
// Draw filled rect.
function draw_title( context ) 
{
    context.save( );
    context.fillStyle = 'lightgrey';
    context.font = "30px Arial";
    context.fillText( "Grid", 150, 150 );
    context.restore();
}
var canvas = document.getElementById( "grid" ); 
var context = canvas.getContext( "2d" );
    
// Draw a grid
draw_grid( context, 80, 80, 'black', 'black' );
context.fillStyle = "#FFFFFF";
var cells = [];
for (var i = 0; i < 10; i++)
{
    for (var j = 0; j < 10; j++)
    {
        var cell = new Cell(i, j);
        cells.push(cell);
        draw_values(context, cell.x, cell.y - 15, "" + cell.flow + "\t|\t" + cell.capacity);
    }
}
  
//Draw source & sink cells
var source = cells.find(function(element){
  return element.i == 1 && element.j == 2;
});
var sink = cells.find(function(element){
  return element.i == 8 && element.j == 7;
});
var moves = Math.floor((Math.random() * (30 - 15 + 1)) + 15);
    
/*function placeEdge(a, b)
{
    draw_line(context, a, b);
    if (!(a === source || a === sink))
    {
        draw_dot(context, a.x, a.y);
        a.marked = true;
    }
    
    if (!(b === source || b === sink))
    {
        draw_dot(context, b.x, b.y);
        b.marked = true;
    }
}*/

function buildGraph(root, goal, pathCount)
{
    pathCount = pathCount || 1;
    var visitedQueue = [root];
	var edges = [];
    var currentMove = 0;
    

	
    while (visitedQueue.length > 0)
    {
        var current = visitedQueue.pop();
        
        if (current === goal)
        {
            console.log(currentMove + " out of " + moves);
            console.log(pathCount);
            return;
        }
        else
        {
            if (currentMove === moves && current != goal)
            {
                buildGraph(root, goal, pathCount + 1);
                return;
            }
        }
        
        var neighbors = current.getNeighborsFrom(cells);
        neighbors = neighbors.filter(function(element){
           return element != root; 
        });
        var next = neighbors[Math.floor(Math.random() * neighbors.length)];
		nextEdge = new Edge(current, next, 0);
        
        if (!(current.marked && next.marked))
        {
            nextEdge.placeEdge();
            currentMove++;
        }
        current = next;
        visitedQueue.push(next);
    }
    
    
}

buildGraph(source, sink);
draw_redDot(context, source.x, source.y);
draw_redDot(context, sink.x, sink.y);

</script>
</html>
